# CLAUDE.md

このファイルは、Claude Code (claude.ai/code) がこのリポジトリで作業する際のガイダンスを提供します。

## プロジェクト概要

Pantriは、献立計画、食材管理、買い物リスト生成をサポートする料理・買い物支援Webアプリケーションです。食品廃棄を減らし、バランスの取れた食事を提案することを目的としています。

### 主要機能
- **献立レコメンドエンジン**: 利用可能な食材、調理時間、栄養バランス、季節要因に基づいて献立を提案
- **スマート冷蔵庫管理**: 写真ベースの食材認識と消費期限追跡
- **インテリジェント買い物リスト**: 献立から買い物リストを自動生成し、既存の食材を除外
- **家族共有**: 家族間で献立と買い物リストを共有
- **食品廃棄削減**: 余った食材を使い切るレシピを提案

## 技術スタック

- **フロントエンド**: Next.js 15.3.4 with TypeScript
- **バックエンド**: AWS Amplify Gen2 (予定)
- **データベース**: Amazon RDS (PostgreSQL) (予定)
- **認証**: Amazon Cognito (予定)
- **ファイルストレージ**: Amazon S3 (食材写真用) (予定)
- **スタイリング**: Tailwind CSS v4, shadcn/ui

## 開発コマンド

### 基本コマンド
- `npm run dev` - Turbopackを使用した開発サーバー起動
- `npm run build` - 本番用ビルド
- `npm run start` - 本番サーバー起動
- `npm run lint` - ESLint実行

### 開発サーバー
開発サーバーは http://localhost:3000 で動作し、より高速なコンパイルのためTurbopackを使用します。

## アーキテクチャ

このアプリケーションは、AWSサービスを使用したサーバーレスアーキテクチャに従います：

### データフロー
1. ユーザーはCognitoを介して認証
2. 食材写真はS3と外部認識APIを通じて処理
3. 献立レコメンドエンジンが利用可能な食材とユーザー設定を分析
4. 献立要件と現在の在庫を比較して買い物リストを生成
5. 家族共有はセキュアなリンクベースのアクセス制御を使用

### 主要コンポーネント
- **食材認識**: 写真ベースの食材識別のための外部API統合
- **レコメンドアルゴリズム**: 食材、好み、栄養、タイミングを考慮した複合ロジック
- **在庫管理**: 食材の数量と消費期限のリアルタイム追跡
- **共有システム**: アクセス権限付きのリンクベース共有

## 開発フェーズ

### フェーズ1（MVP）
コア機能: 認証、基本UI、献立レコメンド、食材管理、買い物リスト

### フェーズ2（機能拡張）
家族プロフィール、余り物レシピ提案、通知

### フェーズ3（最適化）
PWAサポート、パフォーマンス最適化、分析

## 主要開発領域

### フロントエンド優先順位
1. 認証UI
2. 基本レイアウトとナビゲーション
3. 献立レコメンドインターフェース
4. 食材管理インターフェース
5. 買い物リストインターフェース

### バックエンド優先順位
1. AWSインフラストラクチャセットアップ
2. データベーススキーマ設計
3. 認証API
4. 食材管理API
5. レシピ管理API
6. 献立レコメンドエンジン
7. 買い物リストAPI

## TypeScript設定

プロジェクトは厳密なTypeScript設定を使用：
- Target: ES2017
- Module resolution: bundler
- パス マッピング: `@/*` はプロジェクトルートにマップ
- JSX: preserve (Next.js用)

## 重要な考慮事項

- **レスポンシブデザイン**: PC、タブレット、スマートフォンで動作する必要がある
- **画像処理**: 食材認識には注意深いAPI統合が必要
- **データプライバシー**: 個人の食事データは適切に保護する必要がある
- **パフォーマンス**: レシピレコメンドアルゴリズムには最適化が必要
- **国際化**: コンテンツは日本語
- **UI言語**: アプリケーションのインターフェースとコンテンツは主に日本語

## Next.jsの原則

### 1. コア原則
- App Router を標準採用
- TypeScript 必須（ESLint／型エラーは常にゼロ）
- API Routes は使用しない。あらゆるサーバー処理は Server Actions で実装

### 2. ディレクトリレイアウト

```
app/         ルーティング & ページ
components/  汎用 UI（再利用可能・ロジックなし）
lib/         ユーティリティ関数
hooks/       カスタムフック
types/       型定義
constants/   定数
config/      設定値・環境変数ラッパー
services/    外部 API ラッパーやビジネスロジック
```

- 専用（機能固有）コンポーネント … 対応する page.tsx と同階層
- 汎用（再利用可能）コンポーネント … components/ に配置

### 3. データハンドリング

| 依存条件 | 実装方法 |
|---------|---------|
| ユーザー操作に依存しない | server components + Server Actions |
| ユーザー操作に依存する | client components + Server Actions + useSWR |

- 更新は Server Actions、即時反映は useSWR.mutate で楽観的更新
- 認証基盤にはAmazon Cognitoを使用し、Cognitoを利用する実装にはAWS SDKを使用する。

### 4. 表示と状態管理
- UI は極力自作せず、必ず shadcn/ui のコンポーネントを利用
- アイコンは lucide-react を統一使用
- URL 状態は nuqs に統一
- グローバル状態ライブラリは 使用しない（必要時は React Context + useReducer などで最小構成）

### 5. パフォーマンス
- use client / useEffect / useState は最小限、まず RSC
- クライアント側は Suspense でフォールバック
- 動的 import で遅延読み込み、画像は next/image、リンクは next/link
- ルートベースのコード分割を徹底

### 6. フォームとバリデーション
- 制御コンポーネント + react-hook-form
- スキーマ検証は Zod
- クライアント／サーバー両方で入力チェック

### 7. 品質・セキュリティ・テスト

#### 7-1 エラーハンドリング
- ガード節で 早期 return、成功パスは最後にまとめる

#### 7-2 アクセシビリティ
- セマンティック HTML + ARIA、キーボード操作サポート

#### 7-3 Server Actions のセキュリティ指針
- ユーザーが許可された操作だけを Server Action として実装
- 汎用的・多目的なサーバー関数は実装しない

#### 7-4 テスト
- demo/ ディレクトリ に UI ベースのテストページを配置し、すべての Server Actions・クライアント関数を ブラウザ経由で手動検証 できるようにする

### 実装フロー
1. 設計：コア原則とディレクトリ決定
2. データ：取得（useSWR）・更新（Server Actions＋mutate）ルール確立
3. UI / State：shadcn/ui と lucide-react を使い、URL 状態は nuqs
4. パフォーマンス：RSC・Suspense・dynamic import で最適化
5. フォーム & バリデーション：Zod × react-hook-form
6. 品質管理：エラー処理 → アクセシビリティ → 専用 Server Actions → demo/ で手動テスト

## 開発ルール
- コミットメッセージは日本語で書く。また、以下のコミットタイトルをコミットメッセージの前に付ける。
  - fix：修正
  - add：機能追加
  - change：仕様変更（removeする場合もchange）
  - clean：整理（リファクタリング等）
  - upgrade：バージョンアップ
  - revert：変更取り消し
    - 例: `add: brandモデルに◯◯メソッドを追加`